#RELEASE 0

# Write a method that takes an array of integers and an 
# integer to search for. The method should return the index of 
# the item, or nil if the integer is not present in the array. 
# #Don't use built-in array methods like .index. You are allowed 
# to use .length and .each.

# Here's an example of how we might use your method (assuming you call it search_array):

# arr = [42, 89, 23, 1]
# p search_array(arr, 1)
# => 3
# p search_array(arr, 24)
# => nil

#Define a method called search array that takes an array as one argument
#And an integer as another. 
def search_array(array, integer)
index = 0
	while index < array.length 
		if array[index] == integer 
			return index
		end 
		index += 1
	end
	puts "This integer is not included." 
end 

arr = [42, 89, 23, 1]
p search_array(arr, 1)
p search_array (arr, 42)
p search_array (arr, 89)
p search_array (arr, 23)
#----------------------------------------------------------------
#RELEASE 1

#Add a method to your file that takes a number of Fibonacci 
# terms to generate and returns an array of the terms. For 
# example, fib(6) would return [0,1,1,2,3,5]. Your method should 
# work for a large number of terms. To verify your work: the last 
# number in the array generated by fib(100) will be 218922995834555169026. 
# (How can you verify this without having to compare this huge number manually? 
# Be smart with your driver code!)

def fib(num)
#Arr is equal to [0, 1]
arr = [0, 1]
#next index in arr is equal to previous index plus current index.
current_index = arr.length - 1
previous_index = arr.length - 2
# next_index = previous_index + current_index
#Q: How do we find the previous index and current index?
#Until "arr" is the length of "num"
	until arr.length == num 
#Push the "next index" into the array.
		next_number = arr[current_index] + arr[previous_index] 
		arr.push(next_number)
		current_index += 1
		previous_index += 1  
		arr.push
	end

	arr

end 

p fib(6) 
p fib(100)
#------------------------------------------------------------------
#RELEASE 2

# 1. Choose a simple sorting algorithm to learn about. Bubble sort or insertion sort are good ones 
# for beginners, but you're welcome to be more adventurous. 
# =>I chose insertion sort.  
# 2. Form a conceptual understanding of how the algorithm works. What helps you grasp it? Do 
# visualizations help? How can you find the right materials for yourself? 
# => I'm a visual learner so typically seeing someone go through each step and explaining helps. I 
# couldn't find any examples that I visually understood for this method but after reading through 
# several, it seems that it is supposed to sort items by placing the item of larger value to the left,
# while placing items of smaller value to the right of items of larger value.
# 3. Notice your emotional state as you tackle this algorithm: do you feel 
# frustrated, underqualified, stupid, or overwhelmed? Or is it more like excitement and curiosity? How 
# do you think these feelings affect your ability to learn? 
# => I feel stuipd, hopeless, and frustrated, to the point where there is no excitement, but maybe 
# some higher degree of curiosity. When I feel like this, it makes it difficult to want to keep going. 
# I feel like I'll never get it so what's the point? Where else can I look for understanding? 
# 4. Pseudocode a sorting method that takes an array of integers and uses a sorting algorithm. The 
# method should return a sorted version of the array. Your pseudocode should not be Ruby-specific. 

#Define a method called "sort" that takes one argument in its parameter
#Sort numbers from smallest to largest
#Q how do we determine which number is largest?
#current index is equal to 1. 
# => Until current index is greater than the array length minus one:
# => right number is equal to the array's current index. 
# => Left number is equal to the array's current index minus 1. 
# =>   If right number is lower than left number:
# =>   Array's current index equals left number. 
# =>   Array's current index minus one equals right number. 
# => End conditional
# => Current index is equal to current index plus one. 
# End 
# => Return array
#End method
#Write out driver code to test method. 

# 5. Implement the sorting method in Ruby.


